<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>scran_aggregate: scran_aggregate Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">scran_aggregate
   </div>
   <div id="projectbrief">Aggregate expression values across cells</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">scran_aggregate Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Aggregate single-cell expression values.  
<a href="namespacescran__aggregate.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__aggregate_1_1AggregateAcrossCellsBuffers.html">AggregateAcrossCellsBuffers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffers for <code><a class="el" href="namespacescran__aggregate.html#a76e8390729e70654df46d322d2e119ff">aggregate_across_cells()</a></code>.  <a href="structscran__aggregate_1_1AggregateAcrossCellsBuffers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__aggregate_1_1AggregateAcrossCellsOptions.html">AggregateAcrossCellsOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for <code><a class="el" href="namespacescran__aggregate.html#a76e8390729e70654df46d322d2e119ff">aggregate_across_cells()</a></code>.  <a href="structscran__aggregate_1_1AggregateAcrossCellsOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__aggregate_1_1AggregateAcrossCellsResults.html">AggregateAcrossCellsResults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Results of <code><a class="el" href="namespacescran__aggregate.html#a76e8390729e70654df46d322d2e119ff">aggregate_across_cells()</a></code>.  <a href="structscran__aggregate_1_1AggregateAcrossCellsResults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__aggregate_1_1AggregateAcrossGenesBuffers.html">AggregateAcrossGenesBuffers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffers for <code><a class="el" href="namespacescran__aggregate.html#a8c5e32aa2efd50f80d02fcfa00d43837">aggregate_across_genes()</a></code>.  <a href="structscran__aggregate_1_1AggregateAcrossGenesBuffers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__aggregate_1_1AggregateAcrossGenesOptions.html">AggregateAcrossGenesOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for <code><a class="el" href="namespacescran__aggregate.html#a8c5e32aa2efd50f80d02fcfa00d43837">aggregate_across_genes()</a></code>.  <a href="structscran__aggregate_1_1AggregateAcrossGenesOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__aggregate_1_1AggregateAcrossGenesResults.html">AggregateAcrossGenesResults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Results of <code><a class="el" href="namespacescran__aggregate.html#a8c5e32aa2efd50f80d02fcfa00d43837">aggregate_across_genes()</a></code>.  <a href="structscran__aggregate_1_1AggregateAcrossGenesResults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a76e8390729e70654df46d322d2e119ff" id="r_a76e8390729e70654df46d322d2e119ff"><td class="memTemplParams" colspan="2">template&lt;typename Data_ , typename Index_ , typename Factor_ , typename Sum_ , typename Detected_ &gt; </td></tr>
<tr class="memitem:a76e8390729e70654df46d322d2e119ff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran__aggregate.html#a76e8390729e70654df46d322d2e119ff">aggregate_across_cells</a> (const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Data_, Index_ &gt; &amp;input, const Factor_ *factor, const <a class="el" href="structscran__aggregate_1_1AggregateAcrossCellsBuffers.html">AggregateAcrossCellsBuffers</a>&lt; Sum_, Detected_ &gt; &amp;buffers, const <a class="el" href="structscran__aggregate_1_1AggregateAcrossCellsOptions.html">AggregateAcrossCellsOptions</a> &amp;options)</td></tr>
<tr class="separator:a76e8390729e70654df46d322d2e119ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e46dd59466d786b30ad2534055b0b11" id="r_a8e46dd59466d786b30ad2534055b0b11"><td class="memTemplParams" colspan="2">template&lt;typename Sum_  = double, typename Detected_  = int, typename Data_ , typename Index_ , typename Factor_ &gt; </td></tr>
<tr class="memitem:a8e46dd59466d786b30ad2534055b0b11"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran__aggregate_1_1AggregateAcrossCellsResults.html">AggregateAcrossCellsResults</a>&lt; Sum_, Detected_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran__aggregate.html#a8e46dd59466d786b30ad2534055b0b11">aggregate_across_cells</a> (const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Data_, Index_ &gt; &amp;input, const Factor_ *factor, const <a class="el" href="structscran__aggregate_1_1AggregateAcrossCellsOptions.html">AggregateAcrossCellsOptions</a> &amp;options)</td></tr>
<tr class="separator:a8e46dd59466d786b30ad2534055b0b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c5e32aa2efd50f80d02fcfa00d43837" id="r_a8c5e32aa2efd50f80d02fcfa00d43837"><td class="memTemplParams" colspan="2">template&lt;typename Data_ , typename Index_ , typename Gene_ , typename Weight_ , typename Sum_ &gt; </td></tr>
<tr class="memitem:a8c5e32aa2efd50f80d02fcfa00d43837"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran__aggregate.html#a8c5e32aa2efd50f80d02fcfa00d43837">aggregate_across_genes</a> (const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Data_, Index_ &gt; &amp;input, const std::vector&lt; std::tuple&lt; size_t, const Gene_ *, const Weight_ * &gt; &gt; &amp;gene_sets, const <a class="el" href="structscran__aggregate_1_1AggregateAcrossGenesBuffers.html">AggregateAcrossGenesBuffers</a>&lt; Sum_ &gt; &amp;buffers, const <a class="el" href="structscran__aggregate_1_1AggregateAcrossGenesOptions.html">AggregateAcrossGenesOptions</a> &amp;options)</td></tr>
<tr class="separator:a8c5e32aa2efd50f80d02fcfa00d43837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d8a5a38223ceafca7ebaee5110c11f" id="r_a58d8a5a38223ceafca7ebaee5110c11f"><td class="memTemplParams" colspan="2">template&lt;typename Sum_  = double, typename Data_ , typename Index_ , typename Gene_ , typename Weight_ &gt; </td></tr>
<tr class="memitem:a58d8a5a38223ceafca7ebaee5110c11f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran__aggregate_1_1AggregateAcrossGenesResults.html">AggregateAcrossGenesResults</a>&lt; Sum_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran__aggregate.html#a58d8a5a38223ceafca7ebaee5110c11f">aggregate_across_genes</a> (const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Data_, Index_ &gt; &amp;input, const std::vector&lt; std::tuple&lt; size_t, const Gene_ *, const Weight_ * &gt; &gt; &amp;gene_sets, const <a class="el" href="structscran__aggregate_1_1AggregateAcrossGenesOptions.html">AggregateAcrossGenesOptions</a> &amp;options)</td></tr>
<tr class="separator:a58d8a5a38223ceafca7ebaee5110c11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2324eaab6a361f7f767204b62a79764b" id="r_a2324eaab6a361f7f767204b62a79764b"><td class="memTemplParams" colspan="2">template&lt;typename Factor_ , typename Output_ &gt; </td></tr>
<tr class="memitem:a2324eaab6a361f7f767204b62a79764b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Factor_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran__aggregate.html#a2324eaab6a361f7f767204b62a79764b">clean_factor</a> (size_t n, const Factor_ *factor, Output_ *cleaned)</td></tr>
<tr class="separator:a2324eaab6a361f7f767204b62a79764b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac709e5530c7cb6b488e6b727fe91b890" id="r_ac709e5530c7cb6b488e6b727fe91b890"><td class="memTemplParams" colspan="2">template&lt;typename Factor_ , typename Combined_ &gt; </td></tr>
<tr class="memitem:ac709e5530c7cb6b488e6b727fe91b890"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; Factor_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran__aggregate.html#ac709e5530c7cb6b488e6b727fe91b890">combine_factors</a> (size_t n, const std::vector&lt; const Factor_ * &gt; &amp;factors, Combined_ *combined)</td></tr>
<tr class="separator:ac709e5530c7cb6b488e6b727fe91b890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0712c37387535ba42349ae78cd6fd8ff" id="r_a0712c37387535ba42349ae78cd6fd8ff"><td class="memTemplParams" colspan="2">template&lt;typename Factor_ , typename Number_ , typename Combined_ &gt; </td></tr>
<tr class="memitem:a0712c37387535ba42349ae78cd6fd8ff"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; Factor_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran__aggregate.html#a0712c37387535ba42349ae78cd6fd8ff">combine_factors_unused</a> (size_t n, const std::vector&lt; std::pair&lt; const Factor_ *, Number_ &gt; &gt; &amp;factors, Combined_ *combined)</td></tr>
<tr class="separator:a0712c37387535ba42349ae78cd6fd8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Aggregate single-cell expression values. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a76e8390729e70654df46d322d2e119ff" name="a76e8390729e70654df46d322d2e119ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76e8390729e70654df46d322d2e119ff">&#9670;&#160;</a></span>aggregate_across_cells() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Data_ , typename Index_ , typename Factor_ , typename Sum_ , typename Detected_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void scran_aggregate::aggregate_across_cells </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Data_, Index_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Factor_ *&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__aggregate_1_1AggregateAcrossCellsBuffers.html">AggregateAcrossCellsBuffers</a>&lt; Sum_, Detected_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__aggregate_1_1AggregateAcrossCellsOptions.html">AggregateAcrossCellsOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Aggregate expression values across groups of cells for each gene. We report the sum of expression values and the number of cells with detected (i.e., positive) expression values in each group. This is typically used to create pseudo-bulk expression profiles for cluster/sample combinations. Expression values are generally expected to be counts, though the same function can be used to compute the average log-expression.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Data_</td><td>Type of data in the input matrix, should be numeric. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type of index in the input matrix. </td></tr>
    <tr><td class="paramname">Factor_</td><td>Integer type of the factor. </td></tr>
    <tr><td class="paramname">Sum_</td><td>Type of the sum, usually the same as <code>Data</code>. </td></tr>
    <tr><td class="paramname">Detected_</td><td>Type for the number of detected cells, usually integer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">input</td><td>The input matrix where rows are features and columns are cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">factor</td><td>Grouping factor. This is a pointer to an array of length equal to the number of columns of <code>input</code>, containing the factor level (i.e., assigned group) for each cell. All levels should be integers in \([0, N)\) where \(N\) is the number of unique levels/groups. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffers</td><td>Collection of buffers in which to store the aggregate statistics (e.g., sums, number of detected cells) for each level and gene. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e46dd59466d786b30ad2534055b0b11" name="a8e46dd59466d786b30ad2534055b0b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e46dd59466d786b30ad2534055b0b11">&#9670;&#160;</a></span>aggregate_across_cells() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Sum_  = double, typename Detected_  = int, typename Data_ , typename Index_ , typename Factor_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran__aggregate_1_1AggregateAcrossCellsResults.html">AggregateAcrossCellsResults</a>&lt; Sum_, Detected_ &gt; scran_aggregate::aggregate_across_cells </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Data_, Index_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Factor_ *&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__aggregate_1_1AggregateAcrossCellsOptions.html">AggregateAcrossCellsOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="namespacescran__aggregate.html#a76e8390729e70654df46d322d2e119ff">aggregate_across_cells()</a></code> that allocates memory for the results.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Sum_</td><td>Type of the sum, should be numeric. </td></tr>
    <tr><td class="paramname">Detected_</td><td>Type for the number of detected cells, usually integer. </td></tr>
    <tr><td class="paramname">Data_</td><td>Type of data in the input matrix, should be numeric. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type of index in the input matrix. </td></tr>
    <tr><td class="paramname">Factor_</td><td>Integer type of the factor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">input</td><td>The input matrix where rows are features and columns are cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">factor</td><td>Grouping factor. This is a pointer to an array of length equal to the number of columns of <code>input</code>, containing the factor level (i.e., assigned group) for each cell. All levels should be integers in \([0, N)\) where \(N\) is the number of unique levels/groups. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Results of the aggregation, where the available statistics depend on <code><a class="el" href="structscran__aggregate_1_1AggregateAcrossCellsOptions.html" title="Options for aggregate_across_cells().">AggregateAcrossCellsOptions</a></code>. </dd></dl>

</div>
</div>
<a id="a8c5e32aa2efd50f80d02fcfa00d43837" name="a8c5e32aa2efd50f80d02fcfa00d43837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c5e32aa2efd50f80d02fcfa00d43837">&#9670;&#160;</a></span>aggregate_across_genes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Data_ , typename Index_ , typename Gene_ , typename Weight_ , typename Sum_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void scran_aggregate::aggregate_across_genes </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Data_, Index_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; size_t, const Gene_ *, const Weight_ * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>gene_sets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__aggregate_1_1AggregateAcrossGenesBuffers.html">AggregateAcrossGenesBuffers</a>&lt; Sum_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__aggregate_1_1AggregateAcrossGenesOptions.html">AggregateAcrossGenesOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Aggregate expression values across gene sets for each cell. This is used to compute a sum/mean of expression values for one or more gene sets/signatures. Each gene in the set can also be weighted, e.g., to account for the strength of regulatory relationships.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Data_</td><td>Type of data in the input matrix, should be numeric. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type of index in the input matrix. </td></tr>
    <tr><td class="paramname">Gene_</td><td>Integer type for the indices of genes in each set. </td></tr>
    <tr><td class="paramname">Weight_</td><td>Floating-point type for the weights of genes in each set. </td></tr>
    <tr><td class="paramname">Sum_</td><td>Floating-point type of the sum.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">input</td><td>The input matrix where rows are features and columns are cells. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">gene_sets</td><td>Vector of gene sets. Each tuple corresponds to a set and contains (i) the number of genes in the set, (ii) a pointer to the row indices of the genes in the set, and (iii) a pointer to the weights of the genes in the set. The weight pointer may be NULL, in which case all weights are set to 1. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffers</td><td>Collection of buffers in which to store the aggregate statistics (e.g., sums) for each gene set and cell. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58d8a5a38223ceafca7ebaee5110c11f" name="a58d8a5a38223ceafca7ebaee5110c11f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d8a5a38223ceafca7ebaee5110c11f">&#9670;&#160;</a></span>aggregate_across_genes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Sum_  = double, typename Data_ , typename Index_ , typename Gene_ , typename Weight_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran__aggregate_1_1AggregateAcrossGenesResults.html">AggregateAcrossGenesResults</a>&lt; Sum_ &gt; scran_aggregate::aggregate_across_genes </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Data_, Index_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; size_t, const Gene_ *, const Weight_ * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>gene_sets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__aggregate_1_1AggregateAcrossGenesOptions.html">AggregateAcrossGenesOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="namespacescran__aggregate.html#a8c5e32aa2efd50f80d02fcfa00d43837">aggregate_across_genes()</a></code> that allocates memory for the results.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Sum_</td><td>Floating-point type of the sum. </td></tr>
    <tr><td class="paramname">Data_</td><td>Type of data in the input matrix, should be numeric. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type of index in the input matrix. </td></tr>
    <tr><td class="paramname">Gene_</td><td>Integer type for the indices of genes in each set. </td></tr>
    <tr><td class="paramname">Weight_</td><td>Floating-point type for the weights of genes in each set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input matrix where rows are features and columns are cells. </td></tr>
    <tr><td class="paramname">gene_sets</td><td>Vector of gene sets. Each tuple corresponds to a set and contains (i) the number of genes in the set, (ii) a pointer to the row indices of the genes in the set, and (iii) a pointer to the weights of the genes in the set. The weight pointer may be NULL, in which case all weights are set to 1. </td></tr>
    <tr><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Results of the aggregation. </dd></dl>

</div>
</div>
<a id="a2324eaab6a361f7f767204b62a79764b" name="a2324eaab6a361f7f767204b62a79764b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2324eaab6a361f7f767204b62a79764b">&#9670;&#160;</a></span>clean_factor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Factor_ , typename Output_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Factor_ &gt; scran_aggregate::clean_factor </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Factor_ *&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output_ *&#160;</td>
          <td class="paramname"><em>cleaned</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clean up a categorical factor by removing unused levels. This yields the same results as <code><a class="el" href="namespacescran__aggregate.html#ac709e5530c7cb6b488e6b727fe91b890">combine_factors()</a></code> with a single factor.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Factor_</td><td>Factor type. Any type may be used here as long as it is hashable and has an equality operator. </td></tr>
    <tr><td class="paramname">Output_</td><td>Integer type for the cleaned factor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>Number of observations (i.e., cells). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">factor</td><td>Pointer to an array of length <code>n</code> containing a factor. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cleaned</td><td>Pointer to an array of length <code>n</code> in which the cleaned factor is to be stored. All values are integers in \([0, N)\) where \(N\) is the length of the output vector; all integers in this range are guaranteed to be present at least once in <code>cleaned</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sorted vector of the original levels that were observed at least once in <code>factor</code>. For any observation <code>i</code>, it is guaranteed that <code>output[cleaned[i]] == factor[i]</code>. </dd></dl>

</div>
</div>
<a id="ac709e5530c7cb6b488e6b727fe91b890" name="ac709e5530c7cb6b488e6b727fe91b890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac709e5530c7cb6b488e6b727fe91b890">&#9670;&#160;</a></span>combine_factors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Factor_ , typename Combined_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; Factor_ &gt; &gt; scran_aggregate::combine_factors </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const Factor_ * &gt; &amp;&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Combined_ *&#160;</td>
          <td class="paramname"><em>combined</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Factor_</td><td>Factor type. Any type may be used here as long as it implements the comparison operators. </td></tr>
    <tr><td class="paramname">Combined_</td><td>Integer type for the combined factor. This should be large enough to hold the number of unique combinations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>Number of observations (i.e., cells). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>Vector of pointers to arrays of length <code>n</code>, each containing a different factor. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">combined</td><td>Pointer to an array of length <code>n</code> in which the combined factor is to be stored. On output, each entry determines the corresponding observation's combination of levels by indexing into the inner vectors of the returned object, i.e., <code>j := combined[i]</code> represents the combination <code>(output[0][j], output[1][j], ...)</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of vectors containing each unique combinations of factor levels. Each inner vector corresponds to a factor in <code>factors</code>, and all inner vectors have the same length. Corresponding entries of the inner vectors define a particular combination of levels, i.e., the first combination is defined as <code>(output[0][0], output[1][0], ...)</code>, the second combination is defined as <code>(output[0][1], output[1][1], ...)</code>, and so on. Combinations are guaranteed to be sorted by the first factor, then the second, etc. </dd></dl>

</div>
</div>
<a id="a0712c37387535ba42349ae78cd6fd8ff" name="a0712c37387535ba42349ae78cd6fd8ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0712c37387535ba42349ae78cd6fd8ff">&#9670;&#160;</a></span>combine_factors_unused()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Factor_ , typename Number_ , typename Combined_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; Factor_ &gt; &gt; scran_aggregate::combine_factors_unused </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; const Factor_ *, Number_ &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Combined_ *&#160;</td>
          <td class="paramname"><em>combined</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is a variation of <code><a class="el" href="namespacescran__aggregate.html#ac709e5530c7cb6b488e6b727fe91b890">combine_factors()</a></code> that considers unobserved combinations of factor levels.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Factor_</td><td>Factor type. Any type may be used here as long as it is comparable. </td></tr>
    <tr><td class="paramname">Number_</td><td>Integer type for the number of levels in each factor. </td></tr>
    <tr><td class="paramname">Combined_</td><td>Integer type for the combined factor. This should be large enough to hold the number of unique (possibly unused) combinations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>Number of observations (i.e., cells). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>Vector of pairs, each of which corresponds to a factor. The first element of the pair is a pointer to an array of length <code>n</code>, containing the factor level for each observation. The second element is the total number of levels for this factor, which may be greater than the largeset observed level. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">combined</td><td>Pointer to an array of length <code>n</code> in which the combined factor is to be stored. On output, each entry determines the corresponding observation's combination of levels by indexing into the inner vectors of the returned object; see the argument of the same name in <code><a class="el" href="namespacescran__aggregate.html#ac709e5530c7cb6b488e6b727fe91b890">combine_factors()</a></code> for more details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of vectors containing each unique combinations of factor levels. This has the same structure as the output of <code><a class="el" href="namespacescran__aggregate.html#ac709e5530c7cb6b488e6b727fe91b890">combine_factors()</a></code>, with the only difference being that unobserved combinations are also reported. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
