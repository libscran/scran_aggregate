<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>scran_aggregate: scran_aggregate Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">scran_aggregate
   </div>
   <div id="projectbrief">Aggregate expression values across cells</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">scran_aggregate Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Aggregate single-cell expression values.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__aggregate_1_1AggregateAcrossCellsBuffers.html">AggregateAcrossCellsBuffers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffers for <code><a class="el" href="#a455854154026f84c3d8c52a216472c2b">aggregate_across_cells()</a></code>.  <a href="structscran__aggregate_1_1AggregateAcrossCellsBuffers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__aggregate_1_1AggregateAcrossCellsOptions.html">AggregateAcrossCellsOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for <code><a class="el" href="#a455854154026f84c3d8c52a216472c2b">aggregate_across_cells()</a></code>.  <a href="structscran__aggregate_1_1AggregateAcrossCellsOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__aggregate_1_1AggregateAcrossCellsResults.html">AggregateAcrossCellsResults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Results of <code><a class="el" href="#a455854154026f84c3d8c52a216472c2b">aggregate_across_cells()</a></code>.  <a href="structscran__aggregate_1_1AggregateAcrossCellsResults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__aggregate_1_1AggregateAcrossGenesBuffers.html">AggregateAcrossGenesBuffers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffers for <code><a class="el" href="#abf6732ea8012e17cc65039228663eae0">aggregate_across_genes()</a></code>.  <a href="structscran__aggregate_1_1AggregateAcrossGenesBuffers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__aggregate_1_1AggregateAcrossGenesOptions.html">AggregateAcrossGenesOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for <code><a class="el" href="#abf6732ea8012e17cc65039228663eae0">aggregate_across_genes()</a></code>.  <a href="structscran__aggregate_1_1AggregateAcrossGenesOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__aggregate_1_1AggregateAcrossGenesResults.html">AggregateAcrossGenesResults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Results of <code><a class="el" href="#abf6732ea8012e17cc65039228663eae0">aggregate_across_genes()</a></code>.  <a href="structscran__aggregate_1_1AggregateAcrossGenesResults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a455854154026f84c3d8c52a216472c2b" id="r_a455854154026f84c3d8c52a216472c2b"><td class="memTemplParams" colspan="2">template&lt;typename Data_ , typename Index_ , typename Group_ , typename Sum_ , typename Detected_ &gt; </td></tr>
<tr class="memitem:a455854154026f84c3d8c52a216472c2b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a455854154026f84c3d8c52a216472c2b">aggregate_across_cells</a> (const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Data_, Index_ &gt; &amp;input, const Group_ *const group, const <a class="el" href="structscran__aggregate_1_1AggregateAcrossCellsBuffers.html">AggregateAcrossCellsBuffers</a>&lt; Sum_, Detected_ &gt; &amp;buffers, const <a class="el" href="structscran__aggregate_1_1AggregateAcrossCellsOptions.html">AggregateAcrossCellsOptions</a> &amp;options)</td></tr>
<tr class="separator:a455854154026f84c3d8c52a216472c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14dbda14b9307f2c4dbedfd8c3622f5c" id="r_a14dbda14b9307f2c4dbedfd8c3622f5c"><td class="memTemplParams" colspan="2">template&lt;typename Sum_  = double, typename Detected_  = int, typename Data_ , typename Index_ , typename Group_ &gt; </td></tr>
<tr class="memitem:a14dbda14b9307f2c4dbedfd8c3622f5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran__aggregate_1_1AggregateAcrossCellsResults.html">AggregateAcrossCellsResults</a>&lt; Sum_, Detected_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a14dbda14b9307f2c4dbedfd8c3622f5c">aggregate_across_cells</a> (const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Data_, Index_ &gt; &amp;input, const Group_ *const group, const <a class="el" href="structscran__aggregate_1_1AggregateAcrossCellsOptions.html">AggregateAcrossCellsOptions</a> &amp;options)</td></tr>
<tr class="separator:a14dbda14b9307f2c4dbedfd8c3622f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf6732ea8012e17cc65039228663eae0" id="r_abf6732ea8012e17cc65039228663eae0"><td class="memTemplParams" colspan="2">template&lt;typename Data_ , typename Index_ , typename Gene_ , typename Weight_ , typename Sum_ &gt; </td></tr>
<tr class="memitem:abf6732ea8012e17cc65039228663eae0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abf6732ea8012e17cc65039228663eae0">aggregate_across_genes</a> (const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Data_, Index_ &gt; &amp;input, const std::vector&lt; std::tuple&lt; std::size_t, const Gene_ *, const Weight_ * &gt; &gt; &amp;gene_sets, const <a class="el" href="structscran__aggregate_1_1AggregateAcrossGenesBuffers.html">AggregateAcrossGenesBuffers</a>&lt; Sum_ &gt; &amp;buffers, const <a class="el" href="structscran__aggregate_1_1AggregateAcrossGenesOptions.html">AggregateAcrossGenesOptions</a> &amp;options)</td></tr>
<tr class="separator:abf6732ea8012e17cc65039228663eae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20815db8de3133fc282433dfa74443d9" id="r_a20815db8de3133fc282433dfa74443d9"><td class="memTemplParams" colspan="2">template&lt;typename Sum_  = double, typename Data_ , typename Index_ , typename Gene_ , typename Weight_ &gt; </td></tr>
<tr class="memitem:a20815db8de3133fc282433dfa74443d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran__aggregate_1_1AggregateAcrossGenesResults.html">AggregateAcrossGenesResults</a>&lt; Sum_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a20815db8de3133fc282433dfa74443d9">aggregate_across_genes</a> (const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Data_, Index_ &gt; &amp;input, const std::vector&lt; std::tuple&lt; std::size_t, const Gene_ *, const Weight_ * &gt; &gt; &amp;gene_sets, const <a class="el" href="structscran__aggregate_1_1AggregateAcrossGenesOptions.html">AggregateAcrossGenesOptions</a> &amp;options)</td></tr>
<tr class="separator:a20815db8de3133fc282433dfa74443d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14284076a7d9332cd95646e8db4e769" id="r_ac14284076a7d9332cd95646e8db4e769"><td class="memTemplParams" colspan="2">template&lt;typename Factor_ , typename Output_ &gt; </td></tr>
<tr class="memitem:ac14284076a7d9332cd95646e8db4e769"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Factor_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac14284076a7d9332cd95646e8db4e769">clean_factor</a> (const std::size_t n, const Factor_ *const factor, Output_ *const cleaned)</td></tr>
<tr class="separator:ac14284076a7d9332cd95646e8db4e769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80f3b36beb047078b69038867e8e714" id="r_ad80f3b36beb047078b69038867e8e714"><td class="memTemplParams" colspan="2">template&lt;typename Factor_ , typename Combined_ &gt; </td></tr>
<tr class="memitem:ad80f3b36beb047078b69038867e8e714"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; Factor_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad80f3b36beb047078b69038867e8e714">combine_factors</a> (const std::size_t n, const std::vector&lt; const Factor_ * &gt; &amp;factors, Combined_ *const combined)</td></tr>
<tr class="separator:ad80f3b36beb047078b69038867e8e714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252b9226f106b365c068f50a206597e5" id="r_a252b9226f106b365c068f50a206597e5"><td class="memTemplParams" colspan="2">template&lt;typename Factor_ , typename Number_ , typename Combined_ &gt; </td></tr>
<tr class="memitem:a252b9226f106b365c068f50a206597e5"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; Factor_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a252b9226f106b365c068f50a206597e5">combine_factors_unused</a> (const std::size_t n, const std::vector&lt; std::pair&lt; const Factor_ *, Number_ &gt; &gt; &amp;factors, Combined_ *const combined)</td></tr>
<tr class="separator:a252b9226f106b365c068f50a206597e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Aggregate single-cell expression values. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a455854154026f84c3d8c52a216472c2b" name="a455854154026f84c3d8c52a216472c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455854154026f84c3d8c52a216472c2b">&#9670;&#160;</a></span>aggregate_across_cells() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Data_ , typename Index_ , typename Group_ , typename Sum_ , typename Detected_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void scran_aggregate::aggregate_across_cells </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Data_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Group_ *const</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__aggregate_1_1AggregateAcrossCellsBuffers.html">AggregateAcrossCellsBuffers</a>&lt; Sum_, Detected_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__aggregate_1_1AggregateAcrossCellsOptions.html">AggregateAcrossCellsOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Aggregate expression values across groups of cells for each gene. We report the sum of expression values and the number of cells with detected (i.e., positive) expression values in each group. This is typically used to create pseudo-bulk expression profiles for cluster/sample combinations. Expression values are generally expected to be counts so that the sums can be used as if they were counts from bulk data, e.g., for differential analyses with <b>edgeR</b>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Data_</td><td>Type of data in the input matrix, should be numeric. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type of index in the input matrix. </td></tr>
    <tr><td class="paramname">Group_</td><td>Integer type of the group assignments. </td></tr>
    <tr><td class="paramname">Sum_</td><td>Numeric type of the sum, often the same as <code>Data_</code>. </td></tr>
    <tr><td class="paramname">Detected_</td><td>Numeric type (usually integer) of the number of detected cells.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">input</td><td>The input matrix, usually containing non-negative counts. Rows are features and columns are cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>Pointer to an array of length equal to the number of columns of <code>input</code>, containing the assigned group for each cell. All entries should be integers in \([0, N)\) where \(N\) is the number of unique groups. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14dbda14b9307f2c4dbedfd8c3622f5c" name="a14dbda14b9307f2c4dbedfd8c3622f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14dbda14b9307f2c4dbedfd8c3622f5c">&#9670;&#160;</a></span>aggregate_across_cells() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Sum_  = double, typename Detected_  = int, typename Data_ , typename Index_ , typename Group_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran__aggregate_1_1AggregateAcrossCellsResults.html">AggregateAcrossCellsResults</a>&lt; Sum_, Detected_ &gt; scran_aggregate::aggregate_across_cells </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Data_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Group_ *const</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__aggregate_1_1AggregateAcrossCellsOptions.html">AggregateAcrossCellsOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#a455854154026f84c3d8c52a216472c2b">aggregate_across_cells()</a></code> that allocates memory for the results.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Sum_</td><td>Numerict ype of the sum. </td></tr>
    <tr><td class="paramname">Detected_</td><td>Numeric type (usually integer) of the number of detected cells. </td></tr>
    <tr><td class="paramname">Data_</td><td>Type of data in the input matrix, should be numeric. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type of index in the input matrix. </td></tr>
    <tr><td class="paramname">Group_</td><td>Integer type of the group assignments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">input</td><td>The input matrix, usually containing non-negative counts. Rows are features and columns are cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>Pointer to an array of length equal to the number of columns of <code>input</code>, containing the assigned group for each cell. All entries should be integers in \([0, N)\) where \(N\) is the number of unique groups. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Results of the aggregation, where the available statistics depend on <code><a class="el" href="structscran__aggregate_1_1AggregateAcrossCellsOptions.html" title="Options for aggregate_across_cells().">AggregateAcrossCellsOptions</a></code>. </dd></dl>

</div>
</div>
<a id="abf6732ea8012e17cc65039228663eae0" name="abf6732ea8012e17cc65039228663eae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf6732ea8012e17cc65039228663eae0">&#9670;&#160;</a></span>aggregate_across_genes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Data_ , typename Index_ , typename Gene_ , typename Weight_ , typename Sum_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void scran_aggregate::aggregate_across_genes </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Data_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; std::size_t, const Gene_ *, const Weight_ * &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>gene_sets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__aggregate_1_1AggregateAcrossGenesBuffers.html">AggregateAcrossGenesBuffers</a>&lt; Sum_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__aggregate_1_1AggregateAcrossGenesOptions.html">AggregateAcrossGenesOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Aggregate expression values across gene sets for each cell. This involves computing the sum/mean of expression values for any number of gene sets. The aim is to quantify the activity of signatures, pathways or regulons in each cell. Each gene in each set can also be weighted based on any <em>a priori</em> assumptions of their importance to the corresponding pathway.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Data_</td><td>Type of data in the input matrix, should be numeric. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type of index in the input matrix. </td></tr>
    <tr><td class="paramname">Gene_</td><td>Integer type of the indices of genes in each set. </td></tr>
    <tr><td class="paramname">Weight_</td><td>Floating-point type of the weights of genes in each set. </td></tr>
    <tr><td class="paramname">Sum_</td><td>Floating-point type of the sum.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">input</td><td>Matrix of expression values where rows are features and columns are cells. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">gene_sets</td><td>Vector of gene sets. Each tuple corresponds to a set and contains (i) the number of genes in the set, (ii) a pointer to the row indices of the genes in the set, and (iii) a pointer to the weights of the genes in the set. The weight pointer may be <code>NULL</code>, in which case all weights are set to 1. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffers</td><td>Collection of buffers in which to store the sum/mean for each gene set and cell. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20815db8de3133fc282433dfa74443d9" name="a20815db8de3133fc282433dfa74443d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20815db8de3133fc282433dfa74443d9">&#9670;&#160;</a></span>aggregate_across_genes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Sum_  = double, typename Data_ , typename Index_ , typename Gene_ , typename Weight_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran__aggregate_1_1AggregateAcrossGenesResults.html">AggregateAcrossGenesResults</a>&lt; Sum_ &gt; scran_aggregate::aggregate_across_genes </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Data_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; std::size_t, const Gene_ *, const Weight_ * &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>gene_sets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__aggregate_1_1AggregateAcrossGenesOptions.html">AggregateAcrossGenesOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#abf6732ea8012e17cc65039228663eae0">aggregate_across_genes()</a></code> that allocates memory for the results.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Sum_</td><td>Floating-point type of the sum. </td></tr>
    <tr><td class="paramname">Data_</td><td>Type of data in the input matrix, should be numeric. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type of index in the input matrix. </td></tr>
    <tr><td class="paramname">Gene_</td><td>Integer type of the indices of genes in each set. </td></tr>
    <tr><td class="paramname">Weight_</td><td>Floating-point type of the weights of genes in each set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Matrix of expression values where rows are features and columns are cells. </td></tr>
    <tr><td class="paramname">gene_sets</td><td>Vector of gene sets. Each tuple corresponds to a set and contains (i) the number of genes in the set, (ii) a pointer to the row indices of the genes in the set, and (iii) a pointer to the weights of the genes in the set. The weight pointer may be <code>NULL</code>, in which case all weights are set to 1. </td></tr>
    <tr><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Results of the aggregation. </dd></dl>

</div>
</div>
<a id="ac14284076a7d9332cd95646e8db4e769" name="ac14284076a7d9332cd95646e8db4e769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac14284076a7d9332cd95646e8db4e769">&#9670;&#160;</a></span>clean_factor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Factor_ , typename Output_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Factor_ &gt; scran_aggregate::clean_factor </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Factor_ *const</td>          <td class="paramname"><span class="paramname"><em>factor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output_ *const</td>          <td class="paramname"><span class="paramname"><em>cleaned</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clean up a categorical factor by removing unused levels. This yields the same results as <code><a class="el" href="#ad80f3b36beb047078b69038867e8e714">combine_factors()</a></code> with a single factor.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Factor_</td><td>Factor type. Any type may be used here as long as it is hashable and has an equality operator. </td></tr>
    <tr><td class="paramname">Output_</td><td>Integer type for the cleaned factor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>Number of observations (i.e., cells). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">factor</td><td>Pointer to an array of length <code>n</code> containing a factor. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cleaned</td><td>Pointer to an array of length <code>n</code> in which the cleaned factor is to be stored. All values are integers in \([0, N)\) where \(N\) is the length of the output vector; all integers in this range are guaranteed to be present at least once in <code>cleaned</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sorted vector of the original levels that were observed at least once in <code>factor</code>. For any observation <code>i</code>, it is guaranteed that <code>output[cleaned[i]] == factor[i]</code>. </dd></dl>

</div>
</div>
<a id="ad80f3b36beb047078b69038867e8e714" name="ad80f3b36beb047078b69038867e8e714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80f3b36beb047078b69038867e8e714">&#9670;&#160;</a></span>combine_factors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Factor_ , typename Combined_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; Factor_ &gt; &gt; scran_aggregate::combine_factors </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const Factor_ * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>factors</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Combined_ *const</td>          <td class="paramname"><span class="paramname"><em>combined</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Factor_</td><td>Factor type. Any type may be used here as long as it implements the comparison operators. </td></tr>
    <tr><td class="paramname">Combined_</td><td>Integer type for the combined factor. This should be large enough to hold the number of unique combinations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>Number of observations (i.e., cells). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>Vector of pointers to arrays of length <code>n</code>, each containing a different factor. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">combined</td><td>Pointer to an array of length <code>n</code> in which the combined factor is to be stored. On output, each entry determines the corresponding observation's combination of levels by indexing into the inner vectors of the returned object, i.e., <code>j := combined[i]</code> represents the combination <code>(output[0][j], output[1][j], ...)</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of vectors containing each unique combinations of factor levels. Each inner vector corresponds to a factor in <code>factors</code>, and all inner vectors have the same length. Corresponding entries of the inner vectors define a particular combination of levels, i.e., the first combination is defined as <code>(output[0][0], output[1][0], ...)</code>, the second combination is defined as <code>(output[0][1], output[1][1], ...)</code>, and so on. Combinations are guaranteed to be sorted by the first factor, then the second, etc. </dd></dl>

</div>
</div>
<a id="a252b9226f106b365c068f50a206597e5" name="a252b9226f106b365c068f50a206597e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a252b9226f106b365c068f50a206597e5">&#9670;&#160;</a></span>combine_factors_unused()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Factor_ , typename Number_ , typename Combined_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; Factor_ &gt; &gt; scran_aggregate::combine_factors_unused </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; const Factor_ *, Number_ &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>factors</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Combined_ *const</td>          <td class="paramname"><span class="paramname"><em>combined</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is a variation of <code><a class="el" href="#ad80f3b36beb047078b69038867e8e714">combine_factors()</a></code> that considers unobserved combinations of factor levels.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Factor_</td><td>Factor type. Any type may be used here as long as it is comparable. </td></tr>
    <tr><td class="paramname">Number_</td><td>Integer type for the number of levels in each factor. </td></tr>
    <tr><td class="paramname">Combined_</td><td>Integer type for the combined factor. This should be large enough to hold the number of unique (possibly unused) combinations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>Number of observations (i.e., cells). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>Vector of pairs, each of which corresponds to a factor. The first element of the pair is a pointer to an array of length <code>n</code>, containing the factor level for each observation. The second element is the total number of levels for this factor, which may be greater than the largest observed level. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">combined</td><td>Pointer to an array of length <code>n</code> in which the combined factor is to be stored. On output, each entry determines the corresponding observation's combination of levels by indexing into the inner vectors of the returned object; see the argument of the same name in <code><a class="el" href="#ad80f3b36beb047078b69038867e8e714">combine_factors()</a></code> for more details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of vectors containing each unique combinations of factor levels. This has the same structure as the output of <code><a class="el" href="#ad80f3b36beb047078b69038867e8e714">combine_factors()</a></code>, with the only difference being that unobserved combinations are also reported. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
